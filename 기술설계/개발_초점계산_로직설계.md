# TryAngle ê°œë°œìš© ì´ˆì /ê±°ë¦¬ ê³„ì‚° ë¡œì§ ì„¤ê³„

> **ë¬¸ì„œ ëª©ì **: iOS ì•± êµ¬í˜„ì„ ìœ„í•œ ì‹¤ìš©ì  ì„¤ê³„
> **ì‘ì„±ì¼**: 2025-01-20
> **ìµœì¢… ìˆ˜ì •**: 2025-01-20 (ë‹¨ìœ„ ì˜¤ë¥˜ ìˆ˜ì •, ìŠ¤ë¬´ë”©/ë””ë°”ìš´ì‹± ì¶”ê°€)
> **ê´€ë ¨ ë¬¸ì„œ**: ì´ˆì ê³„ì‚°_ë¡œì§ì„¤ê³„.md (í•™ìˆ ìš©)

---

## 1. ì „ì²´ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Gate System (ê¸°ì¡´ ìœ ì§€)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Gate 0: AspectRatio (ë¹„ìœ¨)        â†’ ê·¸ëŒ€ë¡œ                      â”‚
â”‚  Gate 1: Framing (í”„ë ˆì´ë°)        â†’ ê·¸ëŒ€ë¡œ                      â”‚
â”‚  Gate 2: Position (ìœ„ì¹˜)           â†’ ê·¸ëŒ€ë¡œ                      â”‚
â”‚  Gate 3: LensDistance (ë Œì¦ˆ/ê±°ë¦¬)  â†’ ğŸ”¥ ë‚´ë¶€ ë¡œì§ êµì²´           â”‚
â”‚  Gate 4: Pose (í¬ì¦ˆ)               â†’ ê·¸ëŒ€ë¡œ                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Gate 3 ë‚´ë¶€ êµ¬ì¡° (ì‹ ê·œ)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ LensConfig  â”‚    â”‚ Distance    â”‚    â”‚ Guidance    â”‚         â”‚
â”‚  â”‚ (ë Œì¦ˆ ìŠ¤í™) â”‚â”€â”€â”€â–¶â”‚ Estimator   â”‚â”€â”€â”€â–¶â”‚ Calculator  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ (ê±°ë¦¬ ì¶”ì •) â”‚    â”‚ (ê°€ì´ë“œ)    â”‚         â”‚
â”‚         â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                 â–²                  â”‚                 â”‚
â”‚         â”‚                 â”‚                  â–¼                 â”‚
â”‚         â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚         â”‚          â”‚  Keypoint   â”‚    â”‚  Guidance   â”‚         â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Smoother   â”‚    â”‚  Debouncer  â”‚         â”‚
â”‚                    â”‚ (í”ë“¤ë¦¼ë°©ì§€)â”‚    â”‚ (UIì•ˆì •í™”) â”‚         â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ë Œì¦ˆ ì„¤ì • (LensConfig)

### 2.1 ê¸°ê¸°ë³„ ë¬¼ë¦¬ ë Œì¦ˆ ìŠ¤í™ (í•˜ë“œì½”ë”©)

```swift
// DeviceLensConfig.swift

struct DeviceLensConfig {

    /// ê¸°ê¸°ë³„ ë¬¼ë¦¬ ë Œì¦ˆ ìŠ¤í™ [ì¤Œë°°ìœ¨: 35mmí™˜ì‚°ì´ˆì ê±°ë¦¬]
    static let specs: [String: [CGFloat: Int]] = [

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // iPhone 16 ì‹œë¦¬ì¦ˆ (2024)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        "iPhone17,1": [0.5: 13, 1.0: 24, 2.0: 48, 5.0: 120],  // 16 Pro
        "iPhone17,2": [0.5: 13, 1.0: 24, 2.0: 48, 5.0: 120],  // 16 Pro Max
        "iPhone17,3": [0.5: 13, 1.0: 24, 2.0: 48],            // 16
        "iPhone17,4": [0.5: 13, 1.0: 24, 2.0: 48],            // 16 Plus

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // iPhone 15 ì‹œë¦¬ì¦ˆ (2023)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        "iPhone16,1": [0.5: 13, 1.0: 24, 2.0: 48, 3.0: 77],   // 15 Pro
        "iPhone16,2": [0.5: 13, 1.0: 24, 2.0: 48, 5.0: 120],  // 15 Pro Max
        "iPhone15,4": [0.5: 13, 1.0: 24, 2.0: 48],            // 15
        "iPhone15,5": [0.5: 13, 1.0: 24, 2.0: 48],            // 15 Plus

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // iPhone 14 ì‹œë¦¬ì¦ˆ (2022)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        "iPhone15,2": [0.5: 13, 1.0: 24, 2.0: 48, 3.0: 77],   // 14 Pro
        "iPhone15,3": [0.5: 13, 1.0: 24, 2.0: 48, 3.0: 77],   // 14 Pro Max
        "iPhone14,7": [1.0: 26],                               // 14
        "iPhone14,8": [1.0: 26],                               // 14 Plus

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // iPhone 13 ì‹œë¦¬ì¦ˆ (2021)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        "iPhone14,2": [0.5: 13, 1.0: 26, 3.0: 77],            // 13 Pro
        "iPhone14,3": [0.5: 13, 1.0: 26, 3.0: 77],            // 13 Pro Max
        "iPhone14,4": [1.0: 26],                               // 13 mini
        "iPhone14,5": [0.5: 13, 1.0: 26],                      // 13

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // iPhone 12 ì‹œë¦¬ì¦ˆ (2020)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        "iPhone13,1": [0.5: 13, 1.0: 26],                      // 12 mini
        "iPhone13,2": [0.5: 13, 1.0: 26],                      // 12
        "iPhone13,3": [0.5: 13, 1.0: 26, 2.0: 52],            // 12 Pro
        "iPhone13,4": [0.5: 13, 1.0: 26, 2.5: 65],            // 12 Pro Max

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // iPhone SE ì‹œë¦¬ì¦ˆ
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        "iPhone14,6": [1.0: 26],                               // SE 3ì„¸ëŒ€
        "iPhone12,8": [1.0: 26],                               // SE 2ì„¸ëŒ€
    ]

    /// ê¸°ë³¸ê°’ (ì•Œ ìˆ˜ ì—†ëŠ” ê¸°ê¸°ìš©)
    static let defaultSpec: [CGFloat: Int] = [0.5: 13, 1.0: 24, 2.0: 48]

    // MARK: - Instance

    let physicalLenses: [CGFloat: Int]
    let deviceName: String

    init() {
        let modelID = Self.getDeviceModelIdentifier()
        self.deviceName = modelID
        self.physicalLenses = Self.specs[modelID] ?? Self.defaultSpec
    }

    // MARK: - Device Identifier

    private static func getDeviceModelIdentifier() -> String {
        var systemInfo = utsname()
        uname(&systemInfo)
        let machineMirror = Mirror(reflecting: systemInfo.machine)
        let identifier = machineMirror.children.reduce("") { identifier, element in
            guard let value = element.value as? Int8, value != 0 else { return identifier }
            return identifier + String(UnicodeScalar(UInt8(value)))
        }
        return identifier
    }
}
```

### 2.2 ì¤Œ ë°°ìœ¨ â†” ì´ˆì ê±°ë¦¬ ë³€í™˜

```swift
extension DeviceLensConfig {

    // MARK: - ì¤Œ â†’ mm ë³€í™˜ (ì‹¤ì‹œê°„ ì´¬ì˜ìš©)

    /// í˜„ì¬ ì¤Œ ë°°ìœ¨ì—ì„œì˜ 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬ ê³„ì‚°
    /// - Parameter zoom: iOSì—ì„œ ë°›ì€ ì¤Œ ë°°ìœ¨ (0.5, 1.0, 2.5, 3.0 ë“±)
    /// - Returns: 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬ (mm)
    func focalLength(at zoom: CGFloat) -> Int {
        // 1. í˜„ì¬ ì¤Œ ì´í•˜ì˜ ê°€ì¥ ê°€ê¹Œìš´ ë¬¼ë¦¬ ë Œì¦ˆ ì°¾ê¸°
        let baseZoom = physicalLenses.keys
            .filter { $0 <= zoom }
            .max() ?? 1.0

        let baseMM = physicalLenses[baseZoom] ?? 24

        // 2. ë””ì§€í„¸ ì¤Œ ë°°ìœ¨ ê³„ì‚°
        let digitalZoom = zoom / baseZoom

        // 3. ìµœì¢… ì´ˆì ê±°ë¦¬ = ë¬¼ë¦¬ë Œì¦ˆ mm Ã— ë””ì§€í„¸ì¤Œ
        return Int(round(Double(baseMM) * digitalZoom))
    }

    // MARK: - mm â†’ ì¤Œ ë³€í™˜ (UI í‘œì‹œìš©)

    /// ëª©í‘œ ì´ˆì ê±°ë¦¬ë¥¼ ë‹¬ì„±í•˜ê¸° ìœ„í•œ ì¤Œ ë°°ìœ¨ ê³„ì‚°
    /// - Parameter mm: ëª©í‘œ 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬
    /// - Returns: í•„ìš”í•œ ì¤Œ ë°°ìœ¨
    func zoomLevel(for mm: Int) -> CGFloat {
        let target = CGFloat(mm)

        // ë¬¼ë¦¬ ë Œì¦ˆ ì¤‘ ëª©í‘œë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ê²ƒ ì¤‘ ê°€ì¥ í° ê²ƒ ì°¾ê¸°
        let sorted = physicalLenses.sorted { $0.value < $1.value }

        for (zoom, focal) in sorted.reversed() {
            if focal <= mm {
                // í•´ë‹¹ ë¬¼ë¦¬ ë Œì¦ˆ ê¸°ì¤€ìœ¼ë¡œ ë””ì§€í„¸ ì¤Œ ê³„ì‚°
                return zoom * target / CGFloat(focal)
            }
        }

        // fallback: ê°€ì¥ ì‘ì€ ë Œì¦ˆ ê¸°ì¤€
        if let smallest = sorted.first {
            return smallest.key * target / CGFloat(smallest.value)
        }

        return target / 24.0
    }

    // MARK: - ë¬¼ë¦¬ ë Œì¦ˆ ì •ë³´

    /// íŠ¹ì • ì¤Œ ë°°ìœ¨ì´ ë¬¼ë¦¬ ë Œì¦ˆì¸ì§€ í™•ì¸
    func isPhysicalLens(at zoom: CGFloat) -> Bool {
        return physicalLenses.keys.contains(zoom)
    }

    /// ê°€ì¥ ê°€ê¹Œìš´ ë¬¼ë¦¬ ë Œì¦ˆ ì¤Œ ë°°ìœ¨
    func nearestPhysicalLens(to zoom: CGFloat) -> CGFloat {
        return physicalLenses.keys.min(by: { abs($0 - zoom) < abs($1 - zoom) }) ?? 1.0
    }
}
```

### 2.3 ì‚¬ìš© ì˜ˆì‹œ

```swift
// ì•± ì‹œì‘ ì‹œ ì´ˆê¸°í™”
let lensConfig = DeviceLensConfig()
print("ğŸ“· ê¸°ê¸°: \(lensConfig.deviceName)")
print("ğŸ“· ë Œì¦ˆ: \(lensConfig.physicalLenses)")

// ì‹¤ì‹œê°„ ì´¬ì˜ ì¤‘
let currentZoom: CGFloat = 2.5  // iOS APIì—ì„œ ë°›ì€ ê°’
let currentMM = lensConfig.focalLength(at: currentZoom)
print("í˜„ì¬ \(currentZoom)x = \(currentMM)mm")  // "í˜„ì¬ 2.5x = 60mm"

// ë ˆí¼ëŸ°ìŠ¤ ë¶„ì„ í›„ ê°€ì´ë“œ
let targetMM = 77  // EXIFì—ì„œ ì½ì€ ê°’
let targetZoom = lensConfig.zoomLevel(for: targetMM)
print("\(targetMM)mm â†’ \(targetZoom)xë¡œ ì¤Œì¸í•˜ì„¸ìš”")  // "77mm â†’ 3.0xë¡œ ì¤Œì¸í•˜ì„¸ìš”"
```

---

## 3. ë ˆí¼ëŸ°ìŠ¤ ë¶„ì„

### 3.1 ì´ˆì ê±°ë¦¬ ì¶”ì • ìš°ì„ ìˆœìœ„

```
ë ˆí¼ëŸ°ìŠ¤ ì‚¬ì§„ ì…ë ¥
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. EXIF í™•ì¸     â”‚ â”€â”€â–¶ ìˆìœ¼ë©´ ì‚¬ìš© (confidence: 1.0)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ ì—†ìœ¼ë©´
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Focal-Net     â”‚ â”€â”€â–¶ ğŸ”œ ë‚˜ì¤‘ì— ì¶”ê°€ (confidence: 0.8~0.9)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ ì—†ìœ¼ë©´
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Depth ë¶„ì„    â”‚ â”€â”€â–¶ ì••ì¶•ì§€ìˆ˜ë¡œ ì¶”ì • (confidence: 0.5~0.7)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ ì‹¤íŒ¨í•˜ë©´
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Fallback      â”‚ â”€â”€â–¶ 50mm ê¸°ë³¸ê°’ (confidence: 0.3)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 êµ¬í˜„

```swift
// ReferenceFocalLengthEstimator.swift

import UIKit
import ImageIO
import CoreML

class ReferenceFocalLengthEstimator {

    // MARK: - Dependencies

    private let depthAnalyzer: DepthCompressionAnalyzer
    private var focalNet: FocalNetModel?  // ğŸ”œ ë‚˜ì¤‘ì— ì¶”ê°€

    init(depthAnalyzer: DepthCompressionAnalyzer) {
        self.depthAnalyzer = depthAnalyzer
        // focalNet = try? FocalNetModel()  // ğŸ”œ ë‚˜ì¤‘ì—
    }

    // MARK: - Main Entry Point

    /// ë ˆí¼ëŸ°ìŠ¤ ì‚¬ì§„ì˜ ì´ˆì ê±°ë¦¬ ì¶”ì •
    func estimate(
        imageData: Data?,
        image: UIImage,
        depthMap: MLMultiArray?
    ) -> FocalLengthInfo {

        // 1ìˆœìœ„: EXIF
        if let exifResult = extractFromEXIF(imageData) {
            print("ğŸ“ EXIFì—ì„œ ì´ˆì ê±°ë¦¬ ì¶”ì¶œ: \(exifResult.focalLength35mm)mm")
            return exifResult
        }

        // 2ìˆœìœ„: Focal-Net (ğŸ”œ ë‚˜ì¤‘ì— í™œì„±í™”)
        // if let focalNetResult = estimateWithFocalNet(image: image, depthMap: depthMap) {
        //     print("ğŸ“ Focal-Net ì¶”ì •: \(focalNetResult.focalLength35mm)mm")
        //     return focalNetResult
        // }

        // 3ìˆœìœ„: Depth ì••ì¶• ë¶„ì„
        if let depthMap = depthMap,
           let depthResult = estimateFromDepth(depthMap) {
            print("ğŸ“ Depth ë¶„ì„ ì¶”ì •: \(depthResult.focalLength35mm)mm (ì‹ ë¢°ë„: \(Int(depthResult.confidence * 100))%)")
            return depthResult
        }

        // 4ìˆœìœ„: Fallback
        print("ğŸ“ ì´ˆì ê±°ë¦¬ ì •ë³´ ì—†ìŒ - ê¸°ë³¸ê°’ 50mm ì‚¬ìš©")
        return FocalLengthInfo(
            focalLength35mm: 50,
            source: .fallback,
            confidence: 0.3
        )
    }

    // MARK: - 1. EXIF ì¶”ì¶œ

    private func extractFromEXIF(_ imageData: Data?) -> FocalLengthInfo? {
        guard let data = imageData,
              let source = CGImageSourceCreateWithData(data as CFData, nil),
              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
              let exif = properties[kCGImagePropertyExifDictionary as String] as? [String: Any]
        else {
            return nil
        }

        // 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬ (ê°€ì¥ ì •í™•)
        if let focal35mm = exif[kCGImagePropertyExifFocalLenIn35mmFilm as String] as? Int {
            return FocalLengthInfo(
                focalLength35mm: focal35mm,
                source: .exif,
                confidence: 1.0
            )
        }

        // ì‹¤ì œ ì´ˆì ê±°ë¦¬ë§Œ ìˆëŠ” ê²½ìš° (ì„¼ì„œ í¬ê¸° ì¶”ì • í•„ìš”)
        if let focalLength = exif[kCGImagePropertyExifFocalLength as String] as? Double {
            // ìŠ¤ë§ˆíŠ¸í° í‰ê·  crop factor ~6.5x
            let estimated35mm = Int(focalLength * 6.5)
            return FocalLengthInfo(
                focalLength35mm: estimated35mm,
                source: .exif,
                confidence: 0.7
            )
        }

        return nil
    }

    // MARK: - 2. Focal-Net (ğŸ”œ ë‚˜ì¤‘ì— êµ¬í˜„)

    private func estimateWithFocalNet(image: UIImage, depthMap: MLMultiArray?) -> FocalLengthInfo? {
        // TODO: Focal-Net í•™ìŠµ ì™„ë£Œ í›„ êµ¬í˜„
        //
        // guard let focalNet = focalNet,
        //       let depth = depthMap else { return nil }
        //
        // let input = createRGBDInput(image: image, depth: depth)
        // let prediction = focalNet.predict(input)
        //
        // return FocalLengthInfo(
        //     focalLength35mm: prediction.focalLength,
        //     source: .focalNet,
        //     confidence: prediction.confidence
        // )

        return nil
    }

    // MARK: - 3. Depth ì••ì¶• ë¶„ì„

    private func estimateFromDepth(_ depthMap: MLMultiArray) -> FocalLengthInfo? {
        let compressionIndex = depthAnalyzer.calculateCompressionIndex(depthMap)

        // ì••ì¶•ì§€ìˆ˜ â†’ ì´ˆì ê±°ë¦¬ ë§¤í•‘ (íœ´ë¦¬ìŠ¤í‹±)
        // ë†’ì€ ì••ì¶• = ë§ì›, ë‚®ì€ ì••ì¶• = ê´‘ê°
        let (focalLength, confidence) = mapCompressionToFocalLength(compressionIndex)

        return FocalLengthInfo(
            focalLength35mm: focalLength,
            source: .depthEstimate,
            confidence: confidence
        )
    }

    private func mapCompressionToFocalLength(_ compression: Float) -> (Int, Float) {
        // ì••ì¶•ì§€ìˆ˜ ë²”ìœ„: 0.0 (ê¹Šì´ê° í¼) ~ 1.0 (ë‚©ì‘í•¨)
        switch compression {
        case 0.8...:
            return (100, 0.5)  // ê°•í•œ ì••ì¶• â†’ ë§ì›
        case 0.65..<0.8:
            return (77, 0.6)   // ì¤‘ê°• ì••ì¶• â†’ ì¤€ë§ì›
        case 0.5..<0.65:
            return (50, 0.6)   // ì¤‘ê°„ â†’ í‘œì¤€
        case 0.35..<0.5:
            return (35, 0.5)   // ì•½í•œ ì••ì¶• â†’ ì¤€ê´‘ê°
        case 0.2..<0.35:
            return (24, 0.5)   // ê¹Šì´ê° â†’ ê´‘ê°
        default:
            return (13, 0.4)   // ê°•í•œ ê¹Šì´ê° â†’ ì´ˆê´‘ê°
        }
    }
}
```

### 3.3 Depth ì••ì¶• ì§€ìˆ˜ ê³„ì‚°

```swift
// DepthCompressionAnalyzer.swift

class DepthCompressionAnalyzer {

    /// ì••ì¶• ì§€ìˆ˜ ê³„ì‚° (0.0 ~ 1.0)
    /// - 1.0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ì••ì¶•ë¨ (ë§ì› íŠ¹ì„±)
    /// - 0.0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ê¹Šì´ê° ìˆìŒ (ê´‘ê° íŠ¹ì„±)
    func calculateCompressionIndex(_ depthMap: MLMultiArray) -> Float {
        let shape = depthMap.shape
        guard shape.count >= 2 else { return 0.5 }

        let height = shape[0].intValue
        let width = shape.count > 1 ? shape[1].intValue : 1

        guard height > 0 && width > 0 else { return 0.5 }

        // ë°°ê²½ ì˜ì—­ (ìƒë‹¨ 1/4)
        let backgroundDepth = averageDepth(
            depthMap,
            yRange: 0..<(height/4),
            xRange: 0..<width,
            width: width
        )

        // ì „ê²½ ì˜ì—­ (ì¤‘ì•™)
        let foregroundDepth = averageDepth(
            depthMap,
            yRange: (height/3)..<(2*height/3),
            xRange: (width/4)..<(3*width/4),
            width: width
        )

        // ì••ì¶• ì§€ìˆ˜ = 1 - (ê¹Šì´ ì°¨ì´)
        // ì°¨ì´ê°€ ì‘ì„ìˆ˜ë¡ ì••ì¶•ë¨ (ë§ì›)
        let depthDifference = abs(backgroundDepth - foregroundDepth)
        let compressionIndex = 1.0 - min(1.0, depthDifference * 2)

        return compressionIndex
    }

    private func averageDepth(
        _ depthMap: MLMultiArray,
        yRange: Range<Int>,
        xRange: Range<Int>,
        width: Int
    ) -> Float {
        var sum: Float = 0
        var count = 0

        for y in yRange {
            for x in xRange {
                let index = y * width + x
                if index < depthMap.count {
                    sum += depthMap[index].floatValue
                    count += 1
                }
            }
        }

        return count > 0 ? sum / Float(count) : 0.5
    }
}
```

---

## 4. ê±°ë¦¬ ì¶”ì • (í•€í™€ ì¹´ë©”ë¼ ëª¨ë¸)

### 4.1 ê³µì‹

```
distance = (H Ã— f) / (h Ã— W)

where:
  H = ì‹¤ì œ ì–´ê¹¨ ë„ˆë¹„ (mm)
  f = 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬ (mm)
  h = ì–´ê¹¨ í”½ì…€ ë„ˆë¹„ / ì´ë¯¸ì§€ ë„ˆë¹„ (ë¹„ìœ¨, 0~1)
  W = 35mm í•„ë¦„ ê¸°ì¤€ ê°€ë¡œ ë„ˆë¹„ (mm)

âš ï¸ ì¤‘ìš”: 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, ì„¼ì„œ ë„ˆë¹„ë„ 35mm í•„ë¦„ ê¸°ì¤€ ì‚¬ìš©
âš ï¸ 4:3 ë¹„ìœ¨ ë³´ì •: 35mm í•„ë¦„(3:2)ê³¼ ì•„ì´í°(4:3) í™”ê° ì°¨ì´ë¡œ 34.6mm ì‚¬ìš©
```

### 4.2 ì²´í˜•ë³„ ì–´ê¹¨ ë„ˆë¹„

```swift
// BodyType.swift

enum BodyType: String, CaseIterable, Codable {
    case small = "small"    // ìŠ¬ë¦¼/ì—¬ì„±/ì²­ì†Œë…„
    case medium = "medium"  // í‰ê· 
    case large = "large"    // ë„“ì€ ì–´ê¹¨/ë‚¨ì„±

    var shoulderWidthM: Float {
        switch self {
        case .small: return 0.34
        case .medium: return 0.40
        case .large: return 0.46
        }
    }

    var displayName: String {
        switch self {
        case .small: return "ìŠ¬ë¦¼"
        case .medium: return "ë³´í†µ"
        case .large: return "ë„“ìŒ"
        }
    }
}
```

### 4.3 êµ¬í˜„

```swift
// DistanceEstimator.swift

class DistanceEstimator {

    // MARK: - Constants

    /// 35mm í•„ë¦„ ê¸°ì¤€ ê°€ë¡œ ë„ˆë¹„ (mm)
    /// âš ï¸ 4:3 ë¹„ìœ¨ ë³´ì •: ì›ë˜ 36mmì´ì§€ë§Œ, ì•„ì´í°(4:3)ê³¼ 35mmí•„ë¦„(3:2)ì˜
    ///    í™”ê° ì°¨ì´ë¡œ ì¸í•´ 34.6mmê°€ ë” ì •í™•í•¨ (ì•½ 4% ì˜¤ì°¨ ë³´ì •)
    static let sensorReferenceWidthMM: Float = 34.6

    /// ê¸°ë³¸ ì–´ê¹¨ ë„ˆë¹„ (ë¯¸í„°)
    static let defaultShoulderWidthM: Float = 0.40

    // MARK: - Distance Calculation

    /// í•€í™€ ì¹´ë©”ë¼ ëª¨ë¸ë¡œ ê±°ë¦¬ ì¶”ì •
    /// - Parameters:
    ///   - shoulderRatio: ì–´ê¹¨ í”½ì…€ ë„ˆë¹„ / ì´ë¯¸ì§€ ë„ˆë¹„ (0.0 ~ 1.0)
    ///   - focalLengthMM: 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬
    ///   - bodyType: ì²´í˜• (ì–´ê¹¨ ë„ˆë¹„ ê²°ì •)
    /// - Returns: ì¶”ì • ê±°ë¦¬ (ë¯¸í„°)
    func estimateDistance(
        shoulderRatio: Float,
        focalLengthMM: Int,
        bodyType: BodyType = .medium
    ) -> Float {
        guard shoulderRatio > 0.01 else {
            return 5.0  // ì–´ê¹¨ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ê¸°ë³¸ ê±°ë¦¬
        }

        // ë‹¨ìœ„ í†µì¼: ëª¨ë‘ mmë¡œ ê³„ì‚°
        let shoulderWidthMM = bodyType.shoulderWidthM * 1000  // m â†’ mm
        let shoulderOnSensorMM = shoulderRatio * Self.sensorReferenceWidthMM

        // í•€í™€ ê³µì‹: distance = (ì‹¤ì œí¬ê¸° Ã— ì´ˆì ê±°ë¦¬) / ì„¼ì„œìƒí¬ê¸°
        let distanceMM = (shoulderWidthMM * Float(focalLengthMM)) / shoulderOnSensorMM

        // mm â†’ m ë³€í™˜
        let distanceM = distanceMM / 1000.0

        // í•©ë¦¬ì ì¸ ë²”ìœ„ë¡œ í´ë¨í•‘ (0.3m ~ 20m)
        return max(0.3, min(20.0, distanceM))
    }

    // MARK: - Shoulder Ratio Calculation

    /// RTMPose í‚¤í¬ì¸íŠ¸ì—ì„œ ì–´ê¹¨ ë¹„ìœ¨ ê³„ì‚°
    /// - Important: Xì¶• ì°¨ì´ë§Œ ì‚¬ìš© (Yì¶• í‹¸íŠ¸ ë…¸ì´ì¦ˆ ì œê±°)
    func calculateShoulderRatio(
        leftShoulder: CGPoint,
        rightShoulder: CGPoint,
        imageWidth: CGFloat
    ) -> Float {
        // âš ï¸ abs(xì°¨ì´)ë§Œ ì‚¬ìš© - sqrt ì‚¬ìš©í•˜ë©´ í‹¸íŠ¸ ë…¸ì´ì¦ˆ í¬í•¨ë¨
        let shoulderPixelWidth = abs(leftShoulder.x - rightShoulder.x)
        let ratio = Float(shoulderPixelWidth / imageWidth)

        return ratio
    }
}
```

### 4.4 ì–´ê¹¨ ë¹„ìœ¨ ê³„ì‚° ì£¼ì˜ì‚¬í•­

```
âš ï¸ ì¤‘ìš”: Yì¶• ì œì™¸

ì˜ëª»ëœ ë°©ì‹:
shoulder_width = sqrt((x1-x2)Â² + (y1-y2)Â²)  âŒ
â†’ ì–´ê¹¨ê°€ ê¸°ìš¸ì–´ì§€ë©´ ê¸¸ì´ê°€ ëŠ˜ì–´ë‚¨ (ë…¸ì´ì¦ˆ)

ì˜¬ë°”ë¥¸ ë°©ì‹:
shoulder_width = abs(x1 - x2)  âœ…
â†’ ìˆ˜í‰ ê±°ë¦¬ë§Œ ì¸¡ì • (ê¸°ìš¸ê¸° ë¬´ì‹œ)
```

### 4.5 í‚¤í¬ì¸íŠ¸ ìŠ¤ë¬´ë”© (í”ë“¤ë¦¼ ë°©ì§€)

```swift
// KeypointSmoother.swift

/// RTMPose í‚¤í¬ì¸íŠ¸ì˜ í”„ë ˆì„ ê°„ í”ë“¤ë¦¼ì„ ì¤„ì´ëŠ” ìŠ¤ë¬´ë”
/// Exponential Moving Average (EMA) ë°©ì‹ ì‚¬ìš©
class KeypointSmoother {

    // MARK: - Configuration

    /// ìŠ¤ë¬´ë”© ê°•ë„ (0.0~1.0, ë‚®ì„ìˆ˜ë¡ ë¶€ë“œëŸ¬ì›€)
    private let alpha: CGFloat

    /// ì´ì „ ê°’ ì €ì¥
    private var previousLeft: CGPoint?
    private var previousRight: CGPoint?

    init(alpha: CGFloat = 0.3) {
        self.alpha = alpha
    }

    // MARK: - Smoothing

    /// ì–´ê¹¨ í‚¤í¬ì¸íŠ¸ ìŠ¤ë¬´ë”©
    func smooth(
        leftShoulder: CGPoint,
        rightShoulder: CGPoint
    ) -> (left: CGPoint, right: CGPoint) {

        let smoothedLeft: CGPoint
        let smoothedRight: CGPoint

        if let prevLeft = previousLeft, let prevRight = previousRight {
            // EMA: smoothed = previous Ã— (1-Î±) + new Ã— Î±
            smoothedLeft = CGPoint(
                x: prevLeft.x * (1 - alpha) + leftShoulder.x * alpha,
                y: prevLeft.y * (1 - alpha) + leftShoulder.y * alpha
            )
            smoothedRight = CGPoint(
                x: prevRight.x * (1 - alpha) + rightShoulder.x * alpha,
                y: prevRight.y * (1 - alpha) + rightShoulder.y * alpha
            )
        } else {
            // ì²« í”„ë ˆì„ì€ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            smoothedLeft = leftShoulder
            smoothedRight = rightShoulder
        }

        // ì €ì¥
        previousLeft = smoothedLeft
        previousRight = smoothedRight

        return (smoothedLeft, smoothedRight)
    }

    /// ìŠ¤ë¬´ë”© ìƒíƒœ ì´ˆê¸°í™” (ìƒˆ ì„¸ì…˜ ì‹œì‘ ì‹œ)
    func reset() {
        previousLeft = nil
        previousRight = nil
    }
}
```

**ìŠ¤ë¬´ë”© íš¨ê³¼:**
```
alpha = 0.3ì¼ ë•Œ:

ì›ë³¸ (í”ë“¤ë¦¼):     180 â†’ 176 â†’ 183 â†’ 178 â†’ 181
ìŠ¤ë¬´ë”© í›„:         180 â†’ 178.8 â†’ 180.1 â†’ 179.5 â†’ 180.0

â†’ 7í”½ì…€ ì™”ë‹¤ê°”ë‹¤ â†’ 1.5í”½ì…€ ì´ë‚´ë¡œ ì•ˆì •í™”
```

---

## 5. ê°€ì´ë“œ ê³„ì‚°

### 5.1 ë¸íƒ€ ê³„ì‚°

```swift
// GuidanceCalculator.swift

struct GuidanceResult {
    let zoomDelta: CGFloat      // + ë©´ ì¤Œì¸ í•„ìš”, - ë©´ ì¤Œì•„ì›ƒ
    let distanceDelta: Float    // + ë©´ ë’¤ë¡œ, - ë©´ ì•ìœ¼ë¡œ
    let currentZoom: CGFloat
    let targetZoom: CGFloat
    let currentDistance: Float
    let targetDistance: Float
    let feedback: String
}

class GuidanceCalculator {

    private let lensConfig: DeviceLensConfig
    private let distanceEstimator: DistanceEstimator

    init(lensConfig: DeviceLensConfig, distanceEstimator: DistanceEstimator) {
        self.lensConfig = lensConfig
        self.distanceEstimator = distanceEstimator
    }

    func calculate(
        // í˜„ì¬ ìƒíƒœ
        currentZoom: CGFloat,
        currentShoulderRatio: Float,
        // ë ˆí¼ëŸ°ìŠ¤
        referenceFocalMM: Int,
        referenceShoulderRatio: Float
    ) -> GuidanceResult {

        // 1. í˜„ì¬ ì´ˆì ê±°ë¦¬ (mm)
        let currentFocalMM = lensConfig.focalLength(at: currentZoom)

        // 2. í˜„ì¬ ê±°ë¦¬ ì¶”ì •
        let currentDistance = distanceEstimator.estimateDistance(
            shoulderRatio: currentShoulderRatio,
            focalLengthMM: currentFocalMM
        )

        // 3. ëª©í‘œ ê±°ë¦¬ ì¶”ì •
        let targetDistance = distanceEstimator.estimateDistance(
            shoulderRatio: referenceShoulderRatio,
            focalLengthMM: referenceFocalMM
        )

        // 4. ëª©í‘œ ì¤Œ ë°°ìœ¨
        let targetZoom = lensConfig.zoomLevel(for: referenceFocalMM)

        // 5. ë¸íƒ€ ê³„ì‚°
        let zoomDelta = targetZoom - currentZoom
        let distanceDelta = targetDistance - currentDistance

        // 6. í”¼ë“œë°± ìƒì„±
        let feedback = generateFeedback(
            zoomDelta: zoomDelta,
            distanceDelta: distanceDelta,
            targetZoom: targetZoom
        )

        return GuidanceResult(
            zoomDelta: zoomDelta,
            distanceDelta: distanceDelta,
            currentZoom: currentZoom,
            targetZoom: targetZoom,
            currentDistance: currentDistance,
            targetDistance: targetDistance,
            feedback: feedback
        )
    }

    private func generateFeedback(
        zoomDelta: CGFloat,
        distanceDelta: Float,
        targetZoom: CGFloat
    ) -> String {

        var parts: [String] = []

        // ê±°ë¦¬ ê°€ì´ë“œ (ìì—°ì–´)
        if abs(distanceDelta) > 0.25 {
            let stepText = formatDistanceAsSteps(abs(distanceDelta))
            let direction = distanceDelta > 0 ? "ë’¤ë¡œ" : "ì•ìœ¼ë¡œ"
            parts.append("\(stepText) \(direction)")
        }

        // ì¤Œ ê°€ì´ë“œ
        if abs(zoomDelta) > 0.3 {
            let zoomText = String(format: "%.1fx", targetZoom)
            let action = zoomDelta > 0 ? "ì¤Œì¸" : "ì¤Œì•„ì›ƒ"
            parts.append("\(zoomText)ë¡œ \(action)")
        }

        if parts.isEmpty {
            return "ì™„ë²½í•´ìš”!"
        }

        return parts.joined(separator: ", ")
    }

    /// ê±°ë¦¬ë¥¼ ìì—°ì–´ ê±¸ìŒ ìˆ˜ë¡œ ë³€í™˜
    private func formatDistanceAsSteps(_ meters: Float) -> String {
        switch meters {
        case ..<0.3:
            return "ë°˜ ê±¸ìŒ"
        case 0.3..<0.7:
            return "í•œ ê±¸ìŒ"
        case 0.7..<1.2:
            return "í•œë‘ ê±¸ìŒ"
        case 1.2..<2.0:
            return "ë‘ì„¸ ê±¸ìŒ"
        case 2.0..<3.5:
            return "ì„œë„ˆ ê±¸ìŒ"
        default:
            return "ë§ì´"
        }
    }
}

// MARK: - ê°€ì´ë“œ ë””ë°”ìš´ì„œ (UI ë–¨ë¦¼ ë°©ì§€)

/// ê°€ì´ë“œ ê²°ê³¼ì˜ ê¸‰ê²©í•œ ë³€í™”ë¥¼ ë°©ì§€í•˜ì—¬ UI ì•ˆì •í™”
class GuidanceDebouncer {

    // MARK: - Configuration

    /// ìµœì†Œ ì—…ë°ì´íŠ¸ ê°„ê²© (ì´ˆ)
    private let minUpdateInterval: TimeInterval

    /// ìœ ì˜ë¯¸í•œ ë³€í™” ì„ê³„ê°’
    private let significantChangeThreshold: Float

    // MARK: - State

    private var lastDisplayedGuidance: GuidanceResult?
    private var lastUpdateTime: Date = .distantPast

    init(
        minUpdateInterval: TimeInterval = 0.5,
        significantChangeThreshold: Float = 0.25
    ) {
        self.minUpdateInterval = minUpdateInterval
        self.significantChangeThreshold = significantChangeThreshold
    }

    // MARK: - Debouncing

    /// ìƒˆ ê°€ì´ë“œ ê²°ê³¼ë¥¼ UIì— ë°˜ì˜í•´ì•¼ í•˜ëŠ”ì§€ íŒë‹¨
    func shouldUpdate(_ newGuidance: GuidanceResult) -> Bool {
        let now = Date()

        // ìµœì†Œ ê°„ê²© ì²´í¬
        guard now.timeIntervalSince(lastUpdateTime) >= minUpdateInterval else {
            return false
        }

        // ì²« ì—…ë°ì´íŠ¸
        guard let last = lastDisplayedGuidance else {
            lastDisplayedGuidance = newGuidance
            lastUpdateTime = now
            return true
        }

        // ìœ ì˜ë¯¸í•œ ë³€í™” ì²´í¬
        let distanceChange = abs(newGuidance.distanceDelta - last.distanceDelta)
        let zoomChange = abs(Float(newGuidance.zoomDelta - last.zoomDelta))

        let hasSignificantChange =
            distanceChange > significantChangeThreshold ||
            zoomChange > significantChangeThreshold

        if hasSignificantChange {
            lastDisplayedGuidance = newGuidance
            lastUpdateTime = now
            return true
        }

        return false
    }

    /// ê°•ì œ ì—…ë°ì´íŠ¸ (ì˜ˆ: ë ˆí¼ëŸ°ìŠ¤ ë³€ê²½ ì‹œ)
    func forceUpdate(_ guidance: GuidanceResult) {
        lastDisplayedGuidance = guidance
        lastUpdateTime = Date()
    }

    /// ìƒíƒœ ì´ˆê¸°í™”
    func reset() {
        lastDisplayedGuidance = nil
        lastUpdateTime = .distantPast
    }
}
```

### 5.2 Gate 3 í†µí•©

```swift
// LensDistanceGate.swift

class LensDistanceGate: GateModule {
    let name = "ë Œì¦ˆ/ê±°ë¦¬"
    let priority = 3

    private let lensConfig: DeviceLensConfig
    private let distanceEstimator: DistanceEstimator
    private let guidanceCalculator: GuidanceCalculator
    private let focalLengthEstimator: ReferenceFocalLengthEstimator

    // ì„ê³„ê°’
    private let zoomThreshold: CGFloat = 0.3      // ì¤Œ ì˜¤ì°¨ í—ˆìš©
    private let distanceThreshold: Float = 0.5    // ê±°ë¦¬ ì˜¤ì°¨ í—ˆìš© (m)
    private let scoreThreshold: CGFloat = 0.70

    init() {
        self.lensConfig = DeviceLensConfig()
        self.distanceEstimator = DistanceEstimator()
        self.guidanceCalculator = GuidanceCalculator(
            lensConfig: lensConfig,
            distanceEstimator: distanceEstimator
        )
        self.focalLengthEstimator = ReferenceFocalLengthEstimator(
            depthAnalyzer: DepthCompressionAnalyzer()
        )
    }

    func evaluate(context: GateContext) -> GateResult {
        // 1. ë ˆí¼ëŸ°ìŠ¤ ì²´í¬
        guard let reference = context.reference else {
            return createSkippedResult("ë ˆí¼ëŸ°ìŠ¤ ì—†ìŒ")
        }

        // 2. í˜„ì¬ ì–´ê¹¨ í‚¤í¬ì¸íŠ¸ ì¶”ì¶œ
        guard let keypoints = context.analysis.poseResult?.asPoseKeypoints,
              let leftShoulder = keypoints.point(for: .leftShoulder),
              let rightShoulder = keypoints.point(for: .rightShoulder)
        else {
            return createSkippedResult("ì–´ê¹¨ ì¸ì‹ ì‹¤íŒ¨")
        }

        // 3. ë ˆí¼ëŸ°ìŠ¤ ì´ˆì ê±°ë¦¬ ì¶”ì •
        let refFocalInfo = focalLengthEstimator.estimate(
            imageData: reference.imageData,
            image: reference.image,
            depthMap: reference.depthMap
        )

        // 4. í˜„ì¬ ì–´ê¹¨ ë¹„ìœ¨ ê³„ì‚°
        let imageSize = context.analysis.input.imageSize
        let currentShoulderRatio = distanceEstimator.calculateShoulderRatio(
            leftShoulder: leftShoulder,
            rightShoulder: rightShoulder,
            imageWidth: imageSize.width
        )

        // 5. ê°€ì´ë“œ ê³„ì‚°
        let guidance = guidanceCalculator.calculate(
            currentZoom: context.currentZoomFactor,
            currentShoulderRatio: currentShoulderRatio,
            referenceFocalMM: refFocalInfo.focalLength35mm,
            referenceShoulderRatio: reference.shoulderRatio ?? 0.2
        )

        // 6. ì ìˆ˜ ê³„ì‚°
        let zoomScore = 1.0 - min(1.0, abs(guidance.zoomDelta) / 2.0)
        let distScore = 1.0 - min(1.0, abs(guidance.distanceDelta) / 3.0)
        let score = CGFloat(zoomScore * 0.5 + Double(distScore) * 0.5)

        // 7. ê²°ê³¼ ë°˜í™˜
        return GateResult(
            name: name,
            score: score,
            threshold: scoreThreshold,
            feedback: guidance.feedback,
            icon: "ğŸ“",
            category: "lens_distance",
            debugInfo: """
                í˜„ì¬: \(guidance.currentZoom)x (\(lensConfig.focalLength(at: guidance.currentZoom))mm), \(String(format: "%.1fm", guidance.currentDistance))
                ëª©í‘œ: \(guidance.targetZoom)x (\(refFocalInfo.focalLength35mm)mm), \(String(format: "%.1fm", guidance.targetDistance))
                ì‹ ë¢°ë„: \(Int(refFocalInfo.confidence * 100))% (\(refFocalInfo.source))
                """
        )
    }

    private func createSkippedResult(_ reason: String) -> GateResult {
        return GateResult(
            name: name,
            score: 1.0,
            threshold: scoreThreshold,
            feedback: reason,
            icon: "ğŸ“",
            category: "lens_distance_skipped"
        )
    }
}
```

---

## 6. Focal-Net ì¶”ê°€ ë°©ë²• (ë‚˜ì¤‘ì—)

### 6.1 ëª¨ë¸ ì¸í„°í˜ì´ìŠ¤

```swift
// FocalNetModel.swift (ğŸ”œ ë‚˜ì¤‘ì— êµ¬í˜„)

protocol FocalNetModelProtocol {
    func predict(image: UIImage, depthMap: MLMultiArray) -> FocalNetPrediction
}

struct FocalNetPrediction {
    let focalLength35mm: Int      // ì¶”ì •ëœ ì´ˆì ê±°ë¦¬
    let confidence: Float         // ì‹ ë¢°ë„ (0.0 ~ 1.0)
    let zoomClass: ZoomClass      // ë¶„ë¥˜ ê²°ê³¼
}

enum ZoomClass: Int, CaseIterable {
    case ultraWide = 0   // 0.5x (13mm)
    case wide = 1        // 1x (24mm)
    case standard = 2    // 2x (48mm)
    case tele = 3        // 3x (77mm)
    case superTele = 4   // 5x (120mm)

    var approximateMM: Int {
        switch self {
        case .ultraWide: return 13
        case .wide: return 24
        case .standard: return 48
        case .tele: return 77
        case .superTele: return 120
        }
    }
}
```

### 6.2 ReferenceFocalLengthEstimatorì— ì¶”ê°€

```swift
// 2ìˆœìœ„ ì£¼ì„ í•´ì œí•˜ê³  êµ¬í˜„

private func estimateWithFocalNet(image: UIImage, depthMap: MLMultiArray?) -> FocalLengthInfo? {
    guard let focalNet = focalNet,
          let depth = depthMap else { return nil }

    let prediction = focalNet.predict(image: image, depthMap: depth)

    // ì‹ ë¢°ë„ê°€ ë‚®ìœ¼ë©´ ìŠ¤í‚µ
    guard prediction.confidence > 0.6 else { return nil }

    return FocalLengthInfo(
        focalLength35mm: prediction.focalLength35mm,
        source: .focalNet,
        confidence: prediction.confidence
    )
}
```

---

## 7. ë°ì´í„° íƒ€ì… ì •ì˜

```swift
// FocalLengthInfo.swift

struct FocalLengthInfo {
    let focalLength35mm: Int      // 35mm í™˜ì‚° ì´ˆì ê±°ë¦¬
    let source: FocalLengthSource // ì •ë³´ ì¶œì²˜
    let confidence: Float         // ì‹ ë¢°ë„ (0.0 ~ 1.0)
}

enum FocalLengthSource: String {
    case exif = "EXIF"
    case focalNet = "Focal-Net"
    case depthEstimate = "Depthë¶„ì„"
    case userInput = "ì‚¬ìš©ìì…ë ¥"
    case fallback = "ê¸°ë³¸ê°’"
}
```

---

## 8. íŒŒì¼ êµ¬ì¡°

```
TryAngleApp/
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Models/
â”‚   â”‚   â””â”€â”€ BodyType.swift                     â† âœ… ì‹ ê·œ: ì²´í˜• ì˜µì…˜
â”‚   â”‚
â”‚   â”œâ”€â”€ Gates/
â”‚   â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”‚   â”œâ”€â”€ GateTypes.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ GateModule.swift               â† âœ… ìˆ˜ì •: ReferenceData, GateSettings í•„ë“œ ì¶”ê°€
â”‚   â”‚   â”‚   â”œâ”€â”€ GateSystem.swift               â† âœ… ìˆ˜ì •: LensDistanceGate ë“±ë¡
â”‚   â”‚   â”‚   â””â”€â”€ GateOrchestrator.swift
â”‚   â”‚   â””â”€â”€ Modules/
â”‚   â”‚       â”œâ”€â”€ AspectRatioGate.swift
â”‚   â”‚       â”œâ”€â”€ FramingGate.swift
â”‚   â”‚       â”œâ”€â”€ PositionGate.swift
â”‚   â”‚       â”œâ”€â”€ LensDistanceGate.swift         â† âœ… ì‹ ê·œ: ê°€ì´ë“œ ìƒì„± ë¡œì§ í¬í•¨
â”‚   â”‚       â””â”€â”€ PoseGate.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ Modules/
â”‚   â”‚   â”œâ”€â”€ Lens/
â”‚   â”‚   â”‚   â”œâ”€â”€ DeviceLensConfig.swift         â† âœ… ì‹ ê·œ: ê¸°ê¸°ë³„ ë Œì¦ˆ ìŠ¤í™
â”‚   â”‚   â”‚   â”œâ”€â”€ DistanceEstimator.swift        â† âœ… ì‹ ê·œ: í•€í™€ ê±°ë¦¬ ê³„ì‚°
â”‚   â”‚   â”‚   â””â”€â”€ FocalLengthEstimator.swift     â† âœ… ìˆ˜ì •: DeviceLensConfig ì—°ë™
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Pose/
â”‚   â”‚       â””â”€â”€ KeypointSmoother.swift         â† âœ… ì‹ ê·œ: í‚¤í¬ì¸íŠ¸ ìŠ¤ë¬´ë”©
â”‚   â”‚
â”‚   â””â”€â”€ Utils/
â”‚       â””â”€â”€ GuidanceDebouncer.swift            â† âœ… ì‹ ê·œ: UI ì•ˆì •í™”
```

### ì„¤ê³„ ëŒ€ë¹„ ë³€ê²½ì‚¬í•­

| ì„¤ê³„ | ì‹¤ì œ êµ¬í˜„ | ì´ìœ  |
|------|-----------|------|
| GuidanceCalculator.swift (ë³„ë„) | LensDistanceGate ë‚´ë¶€ í†µí•© | ë‹¨ìˆœí™”, ì˜ì¡´ì„± ê°ì†Œ |
| ReferenceFocalLengthEstimator.swift | FocalLengthEstimator.swift ìˆ˜ì • | ê¸°ì¡´ ì½”ë“œ í™œìš©, ì¤‘ë³µ ë°©ì§€ |
| DepthCompressionAnalyzer.swift | ê¸°ì¡´ ì½”ë“œ í™œìš© | ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê¸°ëŠ¥ |
| FocalLengthInfo.swift | FocalLengthEstimator.swift ë‚´ ì •ì˜ | ê¸°ì¡´ êµ¬ì¡° ìœ ì§€ |

---

## 9. ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 1: ê¸°ë³¸ êµ¬í˜„ âœ… ì™„ë£Œ (2025-01-21)

- [x] DeviceLensConfigì— ì§€ì› ê¸°ê¸° ì¶”ê°€ (iPhone 12~16 ì‹œë¦¬ì¦ˆ)
- [ ] í˜„ì¬ ê¸°ê¸°ì—ì„œ ì¤Œ â†” mm ë³€í™˜ í…ŒìŠ¤íŠ¸
- [ ] EXIF ì½ê¸° í…ŒìŠ¤íŠ¸ (ì•„ì´í° ì´¬ì˜ ì‚¬ì§„)
- [ ] EXIF ì—†ëŠ” ì‚¬ì§„ Depth ë¶„ì„ í…ŒìŠ¤íŠ¸
- [x] ì–´ê¹¨ ë¹„ìœ¨ ê³„ì‚° (Xì¶•ë§Œ ì‚¬ìš©) í™•ì¸
- [x] ê±°ë¦¬ ì¶”ì • ê²°ê³¼ í˜„ì‹¤ì„± ê²€ì¦ (34.6mm ì„¼ì„œ ê¸°ì¤€)
- [x] Gate ì‹œìŠ¤í…œê³¼ í†µí•© í…ŒìŠ¤íŠ¸ (ë¹Œë“œ ì„±ê³µ)

### Phase 2: ì•ˆì •í™” âœ… êµ¬í˜„ ì™„ë£Œ (2025-01-21)

- [x] KeypointSmoother êµ¬í˜„ ë° ì ìš©
- [x] GuidanceDebouncer êµ¬í˜„ ë° ì ìš©
- [x] ìì—°ì–´ í”¼ë“œë°± ("Nê±¸ìŒ ë’¤ë¡œ/ì•ìœ¼ë¡œ") êµ¬í˜„
- [ ] UI ë–¨ë¦¼ ì—†ëŠ”ì§€ í™•ì¸ (ì‹¤ê¸°ê¸° í…ŒìŠ¤íŠ¸ í•„ìš”)

### Phase 3: ê°œì¸í™”

- [ ] BodyType ì„¤ì • UI ì¶”ê°€
- [ ] ì²´í˜•ë³„ ê±°ë¦¬ ì˜¤ì°¨ ì¸¡ì •
- [ ] ì„¤ì • ì €ì¥ (UserDefaults)

### ë‚˜ì¤‘ì— í•  ê²ƒ

- [ ] Focal-Net ëª¨ë¸ í•™ìŠµ
- [ ] CoreML ë³€í™˜
- [ ] FocalLengthEstimatorì— í†µí•©
- [ ] A/B í…ŒìŠ¤íŠ¸ (Focal-Net ìœ ë¬´ ë¹„êµ)

---

## 10. í•µì‹¬ ìƒìˆ˜ ìš”ì•½

| ìƒìˆ˜ | ê°’ | ì„¤ëª… |
|------|-----|------|
| sensorReferenceWidthMM | 34.6mm | 35mm í•„ë¦„ ê¸°ì¤€ + 4:3 ë¹„ìœ¨ ë³´ì • |
| shoulderWidth (small) | 0.34m | ìŠ¬ë¦¼/ì—¬ì„±/ì²­ì†Œë…„ |
| shoulderWidth (medium) | 0.40m | í‰ê·  |
| shoulderWidth (large) | 0.46m | ë„“ì€ ì–´ê¹¨/ë‚¨ì„± |
| smoothing alpha | 0.3 | í‚¤í¬ì¸íŠ¸ ìŠ¤ë¬´ë”© ê°•ë„ |
| debounce interval | 0.5ì´ˆ | ìµœì†Œ UI ì—…ë°ì´íŠ¸ ê°„ê²© |
| change threshold | 0.25 | ìœ ì˜ë¯¸í•œ ë³€í™” ì„ê³„ê°’ |

---

## 11. ë³€ê²½ ì´ë ¥

| ë‚ ì§œ | ë‚´ìš© |
|------|------|
| 2025-01-20 | ì´ˆì•ˆ ì‘ì„± |
| 2025-01-20 | ë‹¨ìœ„ ì˜¤ë¥˜ ìˆ˜ì • (7.47mm â†’ 34.6mm, 35mm í™˜ì‚° ê¸°ì¤€) |
| 2025-01-20 | KeypointSmoother ì¶”ê°€ (í”ë“¤ë¦¼ ë°©ì§€) |
| 2025-01-20 | GuidanceDebouncer ì¶”ê°€ (UI ì•ˆì •í™”) |
| 2025-01-20 | BodyType ì²´í˜• ì˜µì…˜ ì¶”ê°€ |
| 2025-01-20 | ìì—°ì–´ í”¼ë“œë°± í¬ë§· ì¶”ê°€ ("í•œë‘ ê±¸ìŒ ë’¤ë¡œ") |
| 2025-01-21 | **êµ¬í˜„ ì™„ë£Œ** - íŒŒì¼ êµ¬ì¡° ì‹¤ì œ êµ¬í˜„ì— ë§ê²Œ ìˆ˜ì •, ì²´í¬ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ |
